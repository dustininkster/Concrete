package dustin.omgandroid;
// import files are automatically generated by android studio
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import java.text.DecimalFormat;


public class MainActivity extends ActionBarActivity {

    TextView sgTextview;// These are just declarations.  I'm telling it to define sgTextview as a TextView android widget
    TextView pwTextview;
    TextView sTextview;
    TextView spwTextview;
    TextView resultTextview;
    Button sgButton;
    Button pwButton;
    Button sButton;
    Button spwButton;
    String selection = "";//I'm declaring a global variable called selection that I need to use between methods

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //When the activity is started, in this case on launch, it runs the onCreate method.  I haven't
        //messed with the savedInstanceState parameter
        super.onCreate(savedInstanceState);
        //This has to be here.  Not sure why.
        setContentView(R.layout.activity_main);
        //This tells it which layout to load.  You can actually control multiple layouts with a single
        //activity.  I opted to make the input screen an entirely new activity rather than just a second
        //layout so that when you hit the "back" hardware button on your android device it will kill the
        //input activity and return to the main activity.  If I had used two layouts with one activity
        //pressing the back button would have exited the entire app.
        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
        //This fixes the screen to portrait.  I didn't see a need to set up a landscape version.  The
        //functionality for it is automatic but the buttons didn't scale right, and I didn't think anyone
        //would use it anyway.  On a side note, switching to horizontal view reloads the layout, and
        //will set all of the text values back to their default (in this case 0), unless you code it to
        //do otherwise.
        sgTextview = (TextView) findViewById(R.id.sg_text);//  These attach the xml widgets to variables
        sgButton = (Button) findViewById(R.id.sg_button);//    in Java.  It just says that sgTextview is a
        pwTextview = (TextView) findViewById(R.id.pw_text);//  textview widget and the findViewById tells
        pwButton = (Button) findViewById(R.id.pw_button);//    it to look for the id we assigned in the activity_main
        sTextview = (TextView) findViewById(R.id.s_text);//    xml file.  When we want to refer to the
        sButton = (Button) findViewById(R.id.s_button);//      widget in Java code we will use these
        spwTextview = (TextView) findViewById(R.id.spw_text);//variables.
        spwButton = (Button) findViewById(R.id.spw_button);
        resultTextview = (TextView) findViewById(R.id.result_text);
    }


    public void inputLaunch(View view) {
        //    This is the method that is launched when a button is pressed.  We defined it with the android:onClick
        //    attribute in the activity_main.xml file.  The view parameter is a reference to the actual
        //    button that was clicked.
        String v = String.valueOf(view);
        //view is an object (specifically an android widget).  I can't do much with that so instead I
        //save it's value in a string.  The "value" is the file path in brackets.
        selection = v.substring(v.lastIndexOf("/") + 1, v.length() - 1);
        //I don't want to have to type the whole file path, so I pare it down to just the file name.
        //Here I tell it to take a substring (part of a string) of v starting one after the last slash
        //and stopping on character before the end of the file path (to get rid of the end bracket).
        //The syntax for the .substring method is stringvariable.substring(startcharacter,endcharacter)
        //startcharacter and endcharacter are integers that indicate the position in the string
        Intent intent = new Intent(this, Input.class).putExtra("bnum", selection);
        //An intent is an external call.  In this case it's a new activity.  This tells it that we are
        //going from "this" (an easy way to refer to the running method; I could have typed inputLaunch
        //I suppose) to the Input.class.  It doesn't have to be another activity within this app.  I could
        //for example, have called the phone's camera.  The putExtra is additional information I'm sending
        //with the intent.  bnum is just a label I can refer to on in the input activity to get that information.
        //In this case I'm sending the button which was pressed to trigger the method.
        startActivityForResult(intent, 100);
        //This pulls the trigger and starts the new activity that we defined in our Intent statement.
        //I used startActivityForResult rather than startActivity because I'm expecting data back (the
        //data that was entered).  This data will be captured by the onActivityResult method below.
        //The first parameter is "intent" which is obviously the intent we want to start.  (It could have
        //been "intent2" or "myFancyIntent" or whatever if we had defined it that way with the Intent
        //statement).  The secont is a numeric code that identifies the information we want to recieve
        //back.  It can be whatever, as long as it's an integer.  Not sure why I picked 100 instead of
        //just 1.
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        //This catches the data returned from the input screen, and deals with it.
        super.onActivityResult(requestCode, resultCode, data);
        //I'm not 100% sure what this is, but I know you have to have it.
        String yams = "";
        //yams may not have been the best variable name.
        DecimalFormat df = new DecimalFormat("###0.00");
        //This defines a format so I don't get crazy floating point decimals to the 10th place
        //Each # tells it to put that character if it's there and not 0.  The 0 tells it to put that
        //digit even if it's 0.
        if (resultCode == 100) {
            //This checks to see if the data we got back was code 100.  In complex programs you may be
            //receiving several codes back at once.  You only want it to run the code below if it's the
            //correct data you're expecting.
            yams = String.valueOf(data.getExtras().get("result"));
            //data is the parameter of this method containing the result of the Intent (input screen)
            //It is returned as a submethod of the extra from the intent from the other activity.
            //I'm taking it's value (to convert it to a string) and storing it in my yams variable.


            switch (selection) {  // A "switch" is like an if statement.  It evaluates selection and sends
                //                   it to the appropriate "case"
                case "sg_button": // if selection = "sg_button"... I could have done this with if(){}
                    sgTextview.setText(yams);// but switch/case is much more readable when there are many
                    break;//                    outcomes.
                case "pw_button":
                    pwTextview.setText(yams);// This tells it which textview to put the returned result
                    break;//                    in based on which button was pressed.
                case "spw_button":
                    spwTextview.setText(yams);  // if they pushed the sample pyc and water button, put
                    break;//                       the result of their input in the corresponding textview
                case "s_button":
                    sTextview.setText(yams);
                    break;// The break statements just tell it to stop and leave the switch.  Otherwise
                //           it would continue executing the cases down the list.

            }


            //below I'm taking the values in the textviews and storing them in doubles.  This is to convert
            //from Strings (text) to doubles (numbers) so that I can do math with them.  I chose the variable
            //names based on the TXDOT test method.
            double z1 = Double.valueOf(String.valueOf(spwTextview.getText()));
            double y = Double.valueOf(String.valueOf(pwTextview.getText()));
            double x = Double.valueOf(String.valueOf(sTextview.getText()));
            double g = Double.valueOf(String.valueOf(sgTextview.getText()));

            if (z1 > 0 && y > 0 && x > 0 && g > 0) {// This if statment is to make sure you have all
                // the numbers before you start doing math. Otherwise you would get some crazy stuff
                // from dividing by zero.
                double z = y + x - (x / g);//math to get your "z" per the test
                double m = (100 * g * (z - z1)) / (x * (g - 1));//math to get your moisture
                resultTextview.setText(String.valueOf(df.format(m) + "%"));
                //sets the result textview with the moisture.  The textview text has to be a string so
                //I'm converting back from a double.  Also I'm using the format we defined earlier and
                //adding a "%" sign.
            } else {
                resultTextview.setText("0.00%"); //This tells it to set the result to 0 if you don't have
                //all of your numbers yet.  If I didn't have this statement and you had all your numbers
                //then set one to zero, you'd get crazy stuff.
            }
        }
    }

}
